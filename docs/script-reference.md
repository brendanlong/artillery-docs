<!-- TODO: Document plugins here and in a page/section of their own -->

# Script Reference #

An Artillery script is composed of two sections: `config` and `scenarios`.

The `config` section defines the target (the application that Artillery will generate load on), the load progression, and protocol-specific settings such as HTTP response timeouts.

The `scenarios` section contains one or more definitions of scenarios that virtual users created by Artillery will execute.

## `config`

- `target` - the URI of the application under test. For an HTTP application it's the base URL for all requests, e.g. `http://myapp.staging.local`. For a WebSocket server it would be the hostname (and optionally the port) of the server, e.g. `ws://127.0.0.1`.
- `environments` - specify a list of environments, and associated target URLs; see below
- `phases` - specify the duration of the test and frequency of requests; see below
- `payload` - used for importing variables from a CSV file; see below
- `defaults` - set default headers that will apply to all HTTP requests
<!-- - `ensure` - cause Artillery to return with a non-zero error code under certain result conditions. Useful for CI -->
- `tls` - configure how Artillery handles self-signed certificates. See [HTTP Reference](http-reference)
<!-- - `timeout` - number of seconds to wait for the server to start responding (send response headers and start the response body). Default value is `10`. -->

### phases ###

A load phase defines how many new virtual users will be generated in a time period. For example, a typical performance test will have a gentle warm up phase, followed by a ramp up phase which is then followed by a maximum load for a duration of time.

`config.phases` is an array of phase definitions that Artillery goes through sequentially. Four kinds of phases are supported:

- A phase with a duration and a constant **arrival rate** of a number of new virtual users per second.
- A linear **ramp up** phase where the number of new arrivals increases linearly over the duration of the phase.
- A phase which generates a fixed **count** of new arrivals over a period of time.
- A **pause** phase which generates no new virtual users for a duration of time.

#### Examples

Create 50 virtual users every second for 5 minutes:

##### Constant arrival rate

```json
config:
  target: "https://staging.example.com"
  phases:
    - duration: 300
      arrivalRate: 50
```

##### A ramp up followed by an constant arrival rate

Ramp up arrival rate from 10 to 50 over 2 minutes, followed by 10 minutes at 50 arrivals per second.

```json
config:
  target: "https://staging.example.com"
  phases:
    - duration: 120
      arrivalRate: 10
      rampTo: 50
      name: "Warm up the application"
    - duration: 600
      arrivalRate: 50
      name: "Sustained max load"
```

(The `name` attributes are optional. They are useful to help identify load phases in the reports generated by Artillery.)

##### Fixed count of arrivals

Create 20 virtual users in 60 seconds (approximately one every 3 seconds):

```json
config:
  target: "https://staging.example.com"
  phases:
    - duration: 60
      arrivalCount: 20
```

##### A do-nothing `pause` phase

```json
config:
  target: "https://staging.example.com"
  phases:
    - pause: 60
```

#### How do ramps work?

Think of a `rampTo` as a shortcut for manually writing out a sequence of arrival phases, e.g. the following ramp:

```json
phases:
  - duration: 100
    arrivalRate: 0
    rampTo: 50
```

is equivalent to:

```json
phases:
  -
    arrivalRate: 0
    duration: 1.96
  -
    arrivalRate: 1
    duration: 1.96
  -
    arrivalRate: 2
    duration: 1.96
  -
     ... etc ...
  -
    arrivalRate: 50
    duration: 2
```

### Environments

Typically we'd want to re-use a load testing script across multiple enviroments (e.g. `dev`, `staging`, and `production`) with minor tweaks. That's what `config.environments` is for: a number of named environments can be defined with environment-specific configuration.

For example, a typical use-case is to define multiple targets with different load phase definitions for each of those:

```json
config:
  target: "http://wontresolve.local:3003"
  phases:
    - duration: 10
      arrivalRate: 1
  environments:
    production:
      target: "http://wontresolve.prod:44321"
      phases:
        - duration: 120
          arrivalRate: 10
    staging:
      target: "http://127.0.0.1:3003"
      phases:
        - duration: 1200
          arrivalRate: 20
scenarios:
  - ...
```

Choose an environment on the command line with the `-e` flag; e.g. `artillery run -e staging my-script.yml`.

### Payload Files

In some cases it is useful to be able to inject data from external files into your test scenarios. For example, you might have a list of usernames and passwords that you want to use to test the auth endpoint in your API.

Payload files are in the CSV format and Artillery allows you to map each of the rows to a variable name that can be used in scenario definitions. For example:

```json
  config:
    payload:
      # path is relative to the location of the test script
      path: "users.csv"
      fields:
        - "username"
        - "password"
  scenarios:
    -
      post:
        url: "/auth"
        json:
          username: "{{ username }}"
          password: "{{ password }}"
```

We tell Artillery to load `users.csv` file and make variables `username` and `password` available in scenarios containing values from one of the rows in the CSV file

To import multiple CSV files `"payload"` may also be an an array:

```json
payload:
  -
    path: "./pets.csv"
    fields:
      - "species"
      - "name"
  -
    path: "./urls.csv"
    fields:
      - "url"
```

#### Ordering

Rows from the CSV file are picked *at random* by default. To iterate through the rows in sequence (looping around and starting from the beginning after the last row has been reached), set the `"order"` attribute to `"sequence"`:

```json
config:
    payload:
      path: "users.csv"
      fields:
        - "username"
        - "password"
      order: "sequence"
  scenarios:
    - # ... the rest of the script
```

### Inline variables

Variables can defined in the ``config.variables`` section of a script and used in subsequent request templates.

```json
  config:
    target: "http://app01.local.dev"
    phases:
      -
        duration: 300
        arrivalRate: 25
    variables:
      postcode:
        - "SE1"
        - "EC1"
        - "E8"
        - "WH9"
      id:
        - "8731"
        - "9965"
        - "2806"
```

The variables can then be used in templates as normal. For example: ``{{ id }}`` and ``{{ postcode }}``.

## `scenarios`

The `scenarios` section is where one or more virtual user scenarios are defined.

A scenario is a sequence of steps that will be run sequentially which represents a typical sequence of requests or messages sent by a user of an application.

A scenario definiton is an object which must contain a `flow` attribute and may contain a number of other attributes.

- `flow` - a "flow" is an array of operations that a virtual user performs, e.g. GET and POST requests for an [HTTP](http-reference)-based application.
- `name` - allows to assign a descriptive name to a scenario, e.g. `"search for a product and get its details"`
- `weight` - allows for the probability of a scenario being picked by a new virtual user to be "weighed" relative to other scenarios

Some Artillery engines will also support other scenario attributes, e.g. the [HTTP engine](http-reference) allows for scenario-level hooks to be defined.

### Scenario weights

Weights allow you to specify that some scenarios should be picked more often than others. If you have three scenarios with weights `1`, `2`, and `5`, the scenario with the weight of `2` is twice as likely to be picked as the one with the weight of `1`, and 2.5 times less likely than the one with weight of `5`. Or in terms of probabilities:

- scenario 1: 1/8 = 12.5% probability of being picked
- scenario 2: 2/8 = 25% probability
- scenario 3: 5/8 = 62.5% probability

Weights are optional, and if not specified are set to `1` (i.e. each scenario is equally likely to be picked).


